# -*- coding: utf-8 -*-
"""Questionario 4 - Redes Complexas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/179CKlc_rZ8Qb7g3a3B_8Hy__1Yb2q3YH

# **SME5924 - Processos Dinâmicos em Redes Complexas**


---


## **Questionário 4**

### Gabriela dos Santos Amaral

# **Introdução**

Notebook contendo os códigos desenvolvidos na linguagem *Python* para responder o questionário 4 da disciplina de Processos Dinâmicos em Redes Complexas (SME5924).
"""

# !pip install python-louvain

# Bibliotecas

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import requests

import random
import math

from networkx.algorithms.community import greedy_modularity_communities
from community import community_louvain

"""# **Questão 1:** Calcule a modularidade para a rede Jazz usando método fastgreedy. Use:

```
G= nx.read_edgelist("data/jazz.txt", nodetype=int)
G = G.to_undirected()
G.remove_edges_from(nx.selfloop_edges(G))
Gcc = sorted(nx.connected_components(G), key=len, reverse=True)
G = G.subgraph(Gcc[0])
G = nx.convert_node_labels_to_integers(G, first_label=0)
```

Primeiro, vamos ler os dados Jazz e visualizar o grafo:
"""

# Leitura da rede
network = 'jazz'
url = f'https://raw.githubusercontent.com/GabrielaSAmaral/ComplexNetworks/main/Dados/{network}.txt'

response = requests.get(url)
with open(f'{network}.txt', 'w') as file:
    file.write(response.text)

G = nx.read_edgelist(f'{network}.txt', nodetype=int)

# Transformando os labels para números inteiros, começando com 0
G = nx.convert_node_labels_to_integers(G, first_label=0)

# Para visualizar a rede
plt.figure(figsize=(35,20))
pos = nx.spring_layout(G, seed = 11) # Definindo uma seed para sempre obter o mesmo gráfico (mesmas posições)
nx.draw(G, pos, node_color='lightgray', node_size=500, with_labels=True)

# Para tranformar a rede em sem direção. Porém, como a rede já é não direcionada, o código não é necessário.
G = G.to_undirected()
G.remove_edges_from(nx.selfloop_edges(G))

"""Vamos selecionar apenas o maior componente conectado:"""

Gcc = sorted(nx.connected_components(G), key=len, reverse=True)
G = G.subgraph(Gcc[0])

# Outra forma
# Gcc = max(nx.connected_components(G), key=len)
# G = G.subgraph(Gcc).copy()

"""Podemos verificar o número de vértices (nodes) e arestas (edges):"""

N = len(G)
M = G.number_of_edges()
print('Número de nós (vértices):', N)
print('Número de arestas:', M)

"""Agora, vamos utilizar o método Fast-Greedy para identificar as comunidades:"""

communities = list(greedy_modularity_communities(G))
for k in range(0,len(communities)):
    print('Community',k,':', sorted(communities[k]))

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

colors = ['red', 'blue', 'green', 'magenta', 'yellow']

fig= plt.figure(figsize=(35,20))
nx.draw(G, pos=pos, node_color = 'white', edge_color='lightgray', style='dashed')
aux = 0
for cm in communities:
    nx.draw(G.subgraph(cm), pos=pos, node_color = colors[aux],
                     with_labels = True, node_size=300, font_color = 'white')
    aux = aux + 1
# plt.savefig('Jazz.eps') #save the figure into a file
plt.show(True)

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Fast-Greedy:"""

def modularity(G, c):
    A = nx.adjacency_matrix(G)
    N = len(G)
    M = G.number_of_edges()
    Q = 0
    for i in np.arange(0,N):
        ki = len(list(G.neighbors(i)))
        for j in np.arange(0,N):
            if(c[i]==c[j]):
                kj = len(list(G.neighbors(j)))
                Q = Q + A[i,j]-(ki*kj)/(2*M)
    Q = Q/(2*M)
    return Q

c = list(greedy_modularity_communities(G))
communities = np.zeros(len(G.nodes()))
nc = 0
for k in range(0,len(c)):
    communities[sorted(c[k])]=nc
    nc = nc+1
    # print('Community:', sorted(c[k]))

print("Modularity Q = %.3f" % modularity(G,communities))

"""# **Questão 2:** Calcule a modularidade para a rede Jazz usando método Louvain. Use:

```
G= nx.read_edgelist("data/jazz.txt", nodetype=int)
G = G.to_undirected()
G.remove_edges_from(nx.selfloop_edges(G))
Gcc = sorted(nx.connected_components(G), key=len, reverse=True)
G = G.subgraph(Gcc[0])
G = nx.convert_node_labels_to_integers(G, first_label=0)
```

Para este exercíco, usaremos a mesma rede da questão 1.

Vamos utilizar o método Louvain para identificar as comunidades:
"""

partitions  = community_louvain.best_partition(G)
print(partitions)

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

fig= plt.figure(figsize=(35,20))
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
size = float(len(set(partitions.values())))
count = 0
for com in set(partitions.values()) :
    count = count + 1.
    list_nodes = [nodes for nodes in partitions.keys() if partitions[nodes] == com]
    nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 50, node_color = colors[int(count)])
nx.draw_networkx_edges(G, pos, alpha=0.3)
plt.show()

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Louvain:"""

modularity = community_louvain.modularity(partitions, G)

modularity = community_louvain.modularity(partitions, G)
print("Modularity Q = %.3f" % modularity)

"""# **Questão 3:** Considere o método de geração de redes LFR_benchmark_graph. Obtenha os valores da modularidade para $\mu=0.05$, $\mu=0.1$, $\mu=0.2$. Use o código a seguir para gerar as redes. Use o algoritmo de Louvain.

```
N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)
```

## $\mu$ = 0.05

Primeiramente, vamos gerar uma rede com o método LFR e $\mu$ = 0.05:
"""

mu = 0.05

N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)

fig= plt.figure(figsize=(35,20))

pos=nx.spring_layout(G)
nx.draw(G, pos=pos, node_color='lightblue', node_size=500, with_labels=True)
plt.show(True)
print('kin=', k*mu*4)

"""Vamos utilizar o método Louvain para identificar as comunidades:"""

partitions  = community_louvain.best_partition(G)
print(partitions)

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

fig= plt.figure(figsize=(35,20))
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
size = float(len(set(partitions.values())))
count = 0
for com in set(partitions.values()) :
    count = count + 1.
    list_nodes = [nodes for nodes in partitions.keys() if partitions[nodes] == com]
    nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 90, node_color = colors[int(count)])
nx.draw_networkx_edges(G, pos, alpha=0.3)
plt.show()

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Louvain:"""

modularity = community_louvain.modularity(partitions, G)
print("Modularity Q = %.3f" % modularity)

"""## $\mu$ = 0.1

Agora, vamos gerar uma rede com o método LFR e $\mu$ = 0.1:
"""

mu = 0.1

N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)

fig= plt.figure(figsize=(35,20))

pos=nx.spring_layout(G)
nx.draw(G, pos=pos, node_color='lightblue', node_size=500, with_labels=True)
plt.show(True)
print('kin=', k*mu*4)

"""Vamos utilizar o método Louvain para identificar as comunidades:"""

partitions  = community_louvain.best_partition(G)
print(partitions)

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

fig= plt.figure(figsize=(35,20))
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
size = float(len(set(partitions.values())))
count = 0
for com in set(partitions.values()) :
    count = count + 1.
    list_nodes = [nodes for nodes in partitions.keys() if partitions[nodes] == com]
    nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 90, node_color = colors[int(count)])
nx.draw_networkx_edges(G, pos, alpha=0.3)
plt.show()

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Louvain:"""

modularity = community_louvain.modularity(partitions, G)
print("Modularity Q = %.3f" % modularity)

"""## $\mu$ = 0.2

Agora, vamos gerar uma rede com o método LFR e $\mu$ = 0.2:
"""

mu = 0.2

N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)

fig= plt.figure(figsize=(35,20))

pos=nx.spring_layout(G)
nx.draw(G, pos=pos, node_color='lightblue', node_size=500, with_labels=True)
plt.show(True)
print('kin=', k*mu*4)

"""Vamos utilizar o método Louvain para identificar as comunidades:"""

partitions  = community_louvain.best_partition(G)
print(partitions)

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

fig= plt.figure(figsize=(35,20))
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
size = float(len(set(partitions.values())))
count = 0
for com in set(partitions.values()) :
    count = count + 1.
    list_nodes = [nodes for nodes in partitions.keys() if partitions[nodes] == com]
    nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 90, node_color = colors[int(count)])
nx.draw_networkx_edges(G, pos, alpha=0.3)
plt.show()

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Louvain:"""

modularity = community_louvain.modularity(partitions, G)
print("Modularity Q = %.3f" % modularity)

"""## Considerações finais

É possível perceber que conforme $\mu$ vai aumentando, as comunidades tendem a ser menos específicas, ou seja, não são tão diferenciáveis entre si. Ao aplicar o método de Louvain, obtemos as seguintes modularidades:

|$\mu$|Modularidade (Q)|
|----|----|
|0.05|0.651|
|0.1|0.550|
|0.2|0.450|

Podemos notar que conforme menor é $\mu$, mais modular é a rede. Portanto, quanto mais específica é uma rede, maior é sua modularidade, e assim, mais detectável são as comunidades.

# **Questão 3:** Considere o método de geração de redes LFR_benchmark_graph. Obtenha os valores da modularidade para $\mu=0.05$, $\mu=0.2$, $\mu=0.4$. Use o código a seguir para gerar as redes. Use o algoritmo fastgreedy.

```
N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)
```

## $\mu$ = 0.05

Primeiramente, vamos gerar uma rede com o método LFR e $\mu$ = 0.05:
"""

mu = 0.05

N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)

fig= plt.figure(figsize=(35,20))

pos=nx.spring_layout(G)
nx.draw(G, pos=pos, node_color='lightblue', node_size=500, with_labels=True)
plt.show(True)
print('kin=', k*mu*4)

"""Agora, vamos utilizar o método Fast-Greedy para identificar as comunidades:"""

communities = list(greedy_modularity_communities(G))
for k in range(0,len(communities)):
    print('Community',k,':', sorted(communities[k]))

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

colors = ['red', 'blue', 'green', 'magenta', 'yellow']

fig= plt.figure(figsize=(35,20))
nx.draw(G, pos=pos, node_color = 'white', edge_color='lightgray', style='dashed')
aux = 0
for cm in communities:
    nx.draw(G.subgraph(cm), pos=pos, node_color = colors[aux],
                     with_labels = True, node_size=300, font_color = 'white')
    aux = aux + 1
plt.show(True)

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Fast-Greedy:"""

def modularity(G, c):
    A = nx.adjacency_matrix(G)
    N = len(G)
    M = G.number_of_edges()
    Q = 0
    for i in np.arange(0,N):
        ki = len(list(G.neighbors(i)))
        for j in np.arange(0,N):
            if(c[i]==c[j]):
                kj = len(list(G.neighbors(j)))
                Q = Q + A[i,j]-(ki*kj)/(2*M)
    Q = Q/(2*M)
    return Q

c = list(greedy_modularity_communities(G))
communities = np.zeros(len(G.nodes()))
nc = 0
for k in range(0,len(c)):
    communities[sorted(c[k])]=nc
    nc = nc+1
    # print('Community:', sorted(c[k]))

print("Modularity Q = %.3f" % modularity(G,communities))

"""## $\mu$ = 0.2

Primeiramente, vamos gerar uma rede com o método LFR e $\mu$ = 0.2:
"""

mu = 0.2

N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)

fig= plt.figure(figsize=(35,20))

pos=nx.spring_layout(G)
nx.draw(G, pos=pos, node_color='lightblue', node_size=500, with_labels=True)
plt.show(True)
print('kin=', k*mu*4)

"""Agora, vamos utilizar o método Fast-Greedy para identificar as comunidades:"""

communities = list(greedy_modularity_communities(G))
for k in range(0,len(communities)):
    print('Community',k,':', sorted(communities[k]))

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

colors = ['red', 'blue', 'green', 'magenta', 'yellow']

fig= plt.figure(figsize=(35,20))
nx.draw(G, pos=pos, node_color = 'white', edge_color='lightgray', style='dashed')
aux = 0
for cm in communities:
    nx.draw(G.subgraph(cm), pos=pos, node_color = colors[aux],
                     with_labels = True, node_size=300, font_color = 'white')
    aux = aux + 1
plt.show(True)

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Fast-Greedy:"""

def modularity(G, c):
    A = nx.adjacency_matrix(G)
    N = len(G)
    M = G.number_of_edges()
    Q = 0
    for i in np.arange(0,N):
        ki = len(list(G.neighbors(i)))
        for j in np.arange(0,N):
            if(c[i]==c[j]):
                kj = len(list(G.neighbors(j)))
                Q = Q + A[i,j]-(ki*kj)/(2*M)
    Q = Q/(2*M)
    return Q

c = list(greedy_modularity_communities(G))
communities = np.zeros(len(G.nodes()))
nc = 0
for k in range(0,len(c)):
    communities[sorted(c[k])]=nc
    nc = nc+1
    # print('Community:', sorted(c[k]))

print("Modularity Q = %.3f" % modularity(G,communities))

"""## $\mu$ = 0.4

Primeiramente, vamos gerar uma rede com o método LFR e $\mu$ = 0.4:
"""

mu = 0.4

N = 128
tau1 = 3
tau2 = 1.5
k =16
minc = 32
maxc = 32

G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)

fig= plt.figure(figsize=(35,20))

pos=nx.spring_layout(G)
nx.draw(G, pos=pos, node_color='lightblue', node_size=500, with_labels=True)
plt.show(True)
print('kin=', k*mu*4)

"""Agora, vamos utilizar o método Fast-Greedy para identificar as comunidades:"""

communities = list(greedy_modularity_communities(G))
for k in range(0,len(communities)):
    print('Community',k,':', sorted(communities[k]))

"""Adicionalmente, podemos fazer um gráfico da rede com cada comunidade destacada:"""

colors = ['red', 'blue', 'green', 'magenta', 'yellow']

fig= plt.figure(figsize=(35,20))
nx.draw(G, pos=pos, node_color = 'white', edge_color='lightgray', style='dashed')
aux = 0
for cm in communities:
    nx.draw(G.subgraph(cm), pos=pos, node_color = colors[aux],
                     with_labels = True, node_size=300, font_color = 'white')
    aux = aux + 1
plt.show(True)

"""Por fim, vamos calcular a medida de modularidade com a utilização do método Fast-Greedy:"""

def modularity(G, c):
    A = nx.adjacency_matrix(G)
    N = len(G)
    M = G.number_of_edges()
    Q = 0
    for i in np.arange(0,N):
        ki = len(list(G.neighbors(i)))
        for j in np.arange(0,N):
            if(c[i]==c[j]):
                kj = len(list(G.neighbors(j)))
                Q = Q + A[i,j]-(ki*kj)/(2*M)
    Q = Q/(2*M)
    return Q

c = list(greedy_modularity_communities(G))
communities = np.zeros(len(G.nodes()))
nc = 0
for k in range(0,len(c)):
    communities[sorted(c[k])]=nc
    nc = nc+1
    # print('Community:', sorted(c[k]))

print("Modularity Q = %.3f" % modularity(G,communities))

"""## Considerações finais

Novamente, é possível perceber que conforme $\mu$ vai aumentando, as comunidades tendem a ser menos específicas, ou seja, não são tão diferenciáveis entre si. Ao aplicar o método de Fast-Greedy, obtemos as seguintes modularidades:

|$\mu$|Modularidade (Q)|
|----|----|
|0.05|0.644|
|0.2|0.435|
|0.4|0.160|

Podemos notar amis uma vez que conforme menor é $\mu$, mais modular é a rede. Portanto, quanto mais específica é uma rede, maior é sua modularidade, e assim, mais detectável são as comunidades.
"""









# Código teste

# mu_list = [0.05, 0.1, 0.2]

# N = 128
# tau1 = 3
# tau2 = 1.5
# k =16
# minc = 32
# maxc = 32

# fig= plt.figure(figsize=(30,13))

# n = 1 # contador
# for mu in mu_list:

#   G = nx.LFR_benchmark_graph(n = N, tau1 = tau1, tau2 = tau2, mu = mu, min_degree = k, max_degree = k, min_community=minc, max_community = maxc, seed = 10)


#   plt.subplot(1, len(mu_list), n)
#   plt.title(rf"Rede Gerada com $\mu$ = {mu}")

#   colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
#   size = float(len(set(partitions.values())))
#   count = 0
#   for com in set(partitions.values()) :
#       count = count + 1.
#       list_nodes = [nodes for nodes in partitions.keys() if partitions[nodes] == com]
#       nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 90, node_color = colors[int(count)])

#   pos=nx.spring_layout(G)
#   nx.draw(G, pos=pos, node_size=100, with_labels = False, edge_color='gray', )
#   print(rf'k_in para mu = {mu}:', k*mu*4)

#   print(f"-------------------- RESULTADOS PARA REDE GERADA COM mu = {mu} --------------------")

#   partitions  = community_louvain.best_partition(G)
#   print("Partição:", partitions)
#   print("------------------------------------------------------------------------------------")

#   n += 1

# plt.show()